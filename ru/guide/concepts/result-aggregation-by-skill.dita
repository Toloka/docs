<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><concept xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsa4="http://dita.oasis-open.org/architecture/2005/" xml:lang="ru" xsi:noNamespaceSchemaLocation="urn:yandex:names:tc:dita:xsd:yandexConcept.xsd:1.3" id="result-aggregation-by-skill">
  <title>Агрегация по навыку</title>
  <abstract>
    <minitoc/>
  </abstract>
  <conbody>
    <p>В заданиях, выданных с <xref href="../glossary.dita#glossary/overlap-ru" popup="yes">перекрытием</xref> 2 и больше, рекомендуется использовать агрегацию ответов. Подробнее об этом процессе читайте в разделе <xref href="result-aggregation.dita">Агрегация результатов</xref>.</p>
    <p>Метод агрегации по навыку анализирует ответы на&#160;основе уровня доверия к&#160;исполнителю. Уровень доверия определяется навыком, который вы выберете. Навык — оценка вероятности того, что исполнитель сделал задание правильно.</p>
    <dl>
      <dlentry>
        <dt>Преимущества</dt>
        <dd>
          <ul>
            <li>Если в&#160;вашем проекте обрабатывается большое количество данных, результаты агрегации будут точнее, по&#160;сравнению с&#160;методом Дэвида&#160;—&#160;Скина.</li>
            <li>Вы сами выбираете поля выходных данных, которые нужно агрегировать.</li>
          </ul>
        </dd>
      </dlentry>
      <dlentry>
        <dt>Особенности</dt>
        <dd>
          <p>Навык пользователя имеет <q>вес</q>. <ph id="about-weight">Чем&#160;выше навык, тем&#160;больше мы доверяем конкретному исполнителю и&#160;считаем, что&#160;его ответ правильный.</ph> </p>
          <p>По&#160;итогам агрегации вы получите TSV-файл с&#160;ответами. Поле <codeph>CONFIDENCE: &lt;название поля <xref href="incoming.dita">выходных данных</xref>&gt;</codeph> — уверенность в&#160;агрегированном ответе. В&#160;нашем случае это вероятность того, что&#160;названный ответ правильный.</p>
          <dl display-style="cut">
            <dlentry>
              <dt>Пример</dt>
              <dd>
                <p>Задания размечали три исполнителя с&#160;разным значением навыка <q>Мой навык</q>: у&#160;первого исполнителя навык — 70, у&#160;второго — 80, у&#160;третьего — 90.
</p>
                <p>На&#160;первое задание все исполнители ответили <uicontrol>OK</uicontrol>. В&#160;этом случае мы уверены на&#160;100%, что&#160;<uicontrol>ОК</uicontrol> — это правильный ответ. </p>
                <p>На&#160;второе задание первый и&#160;третий исполнители ответили <uicontrol>OK</uicontrol>, а&#160;второй — <uicontrol>BAD</uicontrol>. В&#160;этом случае мы сравним навыки исполнителей и на&#160;основе этого посчитаем уверенность в&#160;ответе.</p>
              </dd>
            </dlentry>
            <dlentry>
              <dt>Как вычисляется</dt>
              <dd>
                <p>Термины:</p>
                <ul>
                  <li><tex>q[i]</tex> — точность исполнителя;</li>
                  <li><tex>K</tex> — константа для&#160;сглаживания;</li>
                  <li><tex>z[j]</tex> — наиболее популярный ответ;</li>
                  <li><tex>z[x]</tex> — вероятность того, что&#160;оценка правильная.</li>
                </ul>
                <p>Точность исполнителя <tex>q[i]</tex>  считаем по&#160;формуле: </p>
                <p><tex>q[i] = \frac{K+correct.golden.sets[i]}{2×K+total.golden.sets[i]}</tex>,</p>
                <p>где:</p>
                <p>    <tex>K</tex> — константа для&#160;сглаживания (начиная от 0,5) при&#160;недостаточном количестве ответов на&#160;контрольные задания.</p>
                <p>При&#160;наличии нескольких оценок для&#160;задания высчитывается наиболее популярный ответ — для&#160;каждого варианта ответа суммируем <tex>q[i]</tex> исполнителей, выбравших его. Ответ с&#160;большей суммой считаем более правильным. Назовем эту оценку <tex>z[j] </tex>.
</p>
                <p><xref keyref="baies">По&#160;теореме Байеса</xref> считаем апостериорную вероятность того, что&#160;оценка <tex>z[j]</tex>  правильная.</p>
                <p>В&#160;качестве априорного распределения оценок будет считать равномерное. Для&#160;оценки <tex>z[x]</tex>  априорная вероятность:</p>
                <p><tex>P(z[x]) = \frac{1}{Y}</tex>,</p>
                <p>где: </p>
                <p><tex>Y</tex> — количество вариантов ответов.</p>
                <p>Далее считаем вероятность того, что&#160;оценка <tex>z[j]</tex> правильная.
</p>
                <p>Если исполнитель ответил <tex>z[j]</tex>, то&#160;вероятность этого равна точности исполнителя <tex>q[i]</tex> . Если ответил иначе, то&#160;вероятность этого равна:</p>
                <p><tex>\frac{1-q[i]}{Y-1}</tex>,</p>
                <p>где:</p>
                <p><tex>(1 - q[i])</tex> — оставшаяся вероятность;</p>
                <p><tex>(Y - 1)</tex> — количество оставшихся ответов. </p>
                <p>Таким образом рассчитывается то, что&#160;вероятности ошибок равномерно распределены по&#160;оставшимся оценкам.</p>
                <p>Взяв все ответы исполнителей и, например, вариант <tex>z[x]</tex> , мы считаем вероятность того, что&#160;исполнители ответят таким образом, при условии, что правильным ответом был <tex> z[x]</tex>:</p>
                <codeblock translate="no">func z_prob(x int) : float {
  d = 1.0
  for w[i]: workers
       if answers[w[i]] == z[x]
          d *= q[i]
       else
          d *= (1 - q[i]) / (Y - 1)
  return d
}</codeblock>
                <p> Далее по&#160;теореме Байеса считаем вероятность того, что&#160;ответ <tex>z[j]</tex> правильный:</p>
                <codeblock translate="no">r = 0
for z[i]: answer_options
  r += z_prob(i) * (1 / Y)

eps = z_prob(j) * (1 / Y) / r
</codeblock>
              </dd>
            </dlentry>
          </dl>
          <note id="aggr-task">
            <p>В&#160;агрегации учитываются только принятые задания.</p>
          </note>
        </dd>
      </dlentry>
      <dlentry>
        <dt>Требования</dt>
        <dd>
          <dl display-style="htab">
            <dlentry>
              <dt>Пул с динамическим перекрытием</dt>
              <dd>
                <p>Чтобы запустить агрегацию необходимо корректно настроить динамическое перекрытие. Для этого:</p>
                <ol>
                  <li>Выберите навык. Советуем выбирать навык, рассчитываемый как доля <xref href="goldenset.dita">правильных ответов на контрольные задания</xref>. Тогда результаты агрегации будут наиболее точными.</li>
                  <li>Выберите поля выходных данных.<dl display-style="cut">
                      <dlentry>
                        <dt>Поля выходных данных, которые можно агрегировать</dt>
                        <dd>
                          <ul conref="dynamic-overlap.dita#dynamic-overlap/allowed-fields">
                            <li/>
                          </ul>
                          <p id="allow-value_1">Допустимое значение должно совпадать с параметром <codeph>value</codeph> в нужном элементе интерфейса.</p>
                        </dd>
                      </dlentry>
                    </dl></li>
                </ol>
              </dd>
            </dlentry>
            <dlentry>
              <dt>Пул без динамического перекрытия</dt>
              <dd>
                <p>Вы сможете запустить агрегацию по навыку, если пул соответствует следующим требованиям:</p>
                <ol>
                  <li>У вас есть навык, который определяет уровень доверия к ответам исполнителя. Лучше всего использовать навык, рассчитываемый как доля <xref href="goldenset.dita">правильных ответов на контрольные задания</xref>.</li>
                  <li>В проекте <xref href="incoming.dita">поля выходных данных</xref>, имеют допустимые значения.<dl display-style="cut">
                      <dlentry>
                        <dt>Поля выходных данных, которые можно агрегировать</dt>
                        <dd>
                          <ul conref="dynamic-overlap.dita#dynamic-overlap/allowed-fields">
                            <li/>
                          </ul>
                          <p conref="#result-aggregation-by-skill/allow-value_1"/>
                        </dd>
                      </dlentry>
                    </dl></li>
                  <li>Задания в пул были загружены при помощи <xref href="distribute-tasks-by-pages.dita#distribute-tasks-by-pages/smart-mixing">
                      <q>умного смешивания</q>
                    </xref>.</li>
                </ol>
              </dd>
            </dlentry>
          </dl>
        </dd>
      </dlentry>
    </dl>
  </conbody>
  <concept id="troubleshooting">
    <title>Решение проблем</title>
    <conbody>
      <dl conref="result-aggregation.dita#troubleshooting/result-aggregation-troubleshooting" display-style="cut">
        <dlentry>
          <dt/>
          <dd/>
        </dlentry>
      </dl>
    </conbody>
  </concept>
  <concept id="support">
    <title/>
    <conbody id="toloka-support">
      <p><xref href="../troubleshooting/support.dita#troubleshooting/help">
          <image href="../images/buttons/contact-support.svg"/>
        </xref></p>
    </conbody>
  </concept>
</concept>
